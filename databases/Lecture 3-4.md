Лекция 3-4
==========



Связь
-----



**Определение**: *связь* - упорядоченный список сущностей (не обязательно
различный)

У связи могут быть свои собственные доп. атрибуты.

У свзяи есть *идентификатор, который стр*оится как вектор из идентификаторов
связываемых сущностей.



Однотипные связи объединяются в множества.

>   BTW, ключ - это жаргонизм для идентификатора некоторого объекта



-- тут идёт слайд с ER-диаграммой, где прямоугольники - множества сущностей,
ромбы - множества связей, овалы - атрибуты.



Операций, работающих с отдельными сущностями, действительно нет. Но есть
мета-операции **обобщение** и **специализация**.

Ключ специализации должен совпадать с ключом обобщения.

Множественное наследование возможно, если имеется общее обобщение.



**Пример**: студенты. Они, как бы, люди. А ещё студенты могут работать. Тогда
такой работающий студент, с одной стороны, является сотрудником чего-либо, с
другой - студентом. А сотрудники (как и студенты, в общем-то), тоже люди.

А вот автомобиль Джеймса Бонда, являющий собой машину, самолёт и подводную лодку
плохо вписывается в реальный мир, поэтому смоделировать его как часть реального
мира сложно. Да и не нужно, ибо когда вы в последний раз видели агента 007?



При наследовании атрибуты более широкого класса не копируются, они и так берутся
оттуда.



### Ограничения

Для каждой связи указывается её "кратность". Например, для бинарных связей:

-   0:1 - либо есть, либо нет

-   1:n - 1 или несколько

-   0:n - нет или несколько

-   m:n



### Агрегирование

Операция агрегирования позволяет строить большие комплексы, содержащие несколько
типов сущеностей и связи. Т.е. мы объединяем некоторые объекты диаграммы
объединять в один прямоугольник и один ромб.

Существуют расширения модели Сущность-Связь:



Существует понятие **слабой сущности**, которая не может существовать без связи
с сильной сущностью. Иногда есть выбор между моделированием чего-либо как слабой
сущности или в качестве атрибута.

**Например**: дети сотрудников в информационной системе предприятия (для раздачи
подарков на новый год, например) определённо являются слабыми сущностями. А вот
телефон или почтовый адрес могут быть и атрибутами, и слабыми сущностями (если
мы хотим выделить структуру номера / адреса).

Существуют объектные расширения, добавляющие методы, например.

Т.е. модель развивается до сих пор.



>   Вероятно, многое было забыто и упущено, так что полистайте учебник, а.



Предикатное представление модели сущность-связь
-----------------------------------------------

Множество сущностей описывается предикатом, аргументы которого соответсвуют
атрибутам сущностей.



### Пример предикатного представления

-   `Producer(name, address, group)`

-   `Consumer(name, address, account)`

-   `Product(model)`

-   `Feature(name)`

-   `Has(product, feature, value)`

-   `Buys(consumer, product)`

-   `Makes(producer, product)`

Такое представление абсолютно эквивалентно диаграмме! В таком виде гораздо проще
производить какую-либо автоматическую обработку (поиск, например).



Реляционная модель
==================

Немного истории можно посмотреть на слайдах.

В чистом виде эта модель никогда и нигде не была реализована. Т.е. рассматривать
мы будем абсолютно глухую теорию, не имеющую никакого практического значения. В
реальности это всё бесполезно!



Несмотря на активные попытки потеснить эту модель (особенно в последние годы),
она всё ещё доминирует.



Начнём со структур данных. А они начинаются с домена.



**Определение**: домен - множество значений, которые можно использовать. Они
скалярны, т.е. никак не структурированы.



Имеются **отношения** - многоместные предикаты, заданные на прямом произведении
доменов.

>   Обязательно должно быть определено отношение равенства на домене, т.е.
>   должна быть возможность проверить, совпадают ли два значения из домена. Без
>   этого не построить теорию. Остальное нужно для приложений, а не теории.

Предикат можно записать как подмножество прямого произведения, для которых он
обращается в истину. При записи отношения в БД выписывается как раз это
подмножество



**Атрибут** - аргумент отношения



Всё то же самое можно записать формально. И это так и сделано в слайдах, а сюда
перепечатывать это смысла нет.

Прямое произведение некоммутативно, а нам этого не хотелось бы. Для этого есть
workaround, смотри его в книге Дейта.



Базовые операции
----------------

Реляционная модель обладает некоторыми операциями, которые образуют алгебру (в
её математическом смысле). Эти операции определены на множестве всех возможных
отношений. А каждая операция определена не на всех возможных значениях операндов
(И такое бывает, ведь на 0 делить нельзя). Для нас будет важно основное свойство
алгебры: результат применения операции к элементам алгебры сам лежит в алгебре.

-   Ограничение (селекция, фильтрация) по предикату - выбирает некоторое
    подмножество из множества значений, удовлетворяющих условию предиката. (Если
    рассматривать отношение как функцию, то это будет ограничение функции на
    меньшее множество)

-   Проекция - операция, которая "выбрасывает" часть атрибутов исходного
    отношения

-   Прямое произведение - если рассмотреть отношения как множества, то можно
    взять их прямое произведение

-   Соединение (является составной операцией произведения и ограничения)

На слайдах имеются примеры работы этих операций



На основе базисных операций определяется самая важная операция этой модели -
соединение (join).

>   НИКОГДА, СЛЫШИТЕ, **НИКОГДА** НЕ ПУТАЙТЕ *ОБЪЕДИНЕНИЕ* И *СОЕДИНЕНИЕ*!!!11

-   Тета-соединение - прямое произведение с последующей фильтрацией

-   Эквисоединение - вычисляем прямое произведение. Имеется выделенный атрибут в
    первом отношении и выделенный атрибут во втором отношении (находящийся в том
    же домене). Производится фильтрация, которая оставляет только те кортежи, у
    которых эти атрибуты совпадают.

-   Ествественное соединение - исключаются дублирующие атрибуты



Отобразим нашу сухую теорию на практику, т.е. язык SQL.

-   Понятия домена не существует

-   Атрибуты → колонки

-   Отношения → таблицы

-   Кортежи → строки

-   Уникальность строк не требуется

-   Все операции реляционной алгебры присутствуют



А почему нам хватит одних лишь таблиц? Как же структура? Ответов два:

-   Люди пытаются ввести что-то ещё, но тогда операции алгебры страновятся менее
    чётко определёнными и многие полезные свойства утрачиваются.

-   Содержится на соответствующем слайде. А именно, можно перейти к таблицам со
    скалярными значениями. Процесс превращения вложенных таблиц к невложенным
    называется **приведением к первой нормальной форме**.

Появляется большая избыточность, да. Но мы поговорим об этом чуть позже.



Вспомним о важных свойствах моделей: ограничения целостности и идентификация.

**Определение**: *функциональной зависимостью* называется функция, которая
позволяет по значениям некоторого набора атрибутов отношения однозначно
определить значения других атрибутов.

**Например**: кафедра и факультет функционально зависимы.

Такую функцию выписывать нам не надо, важно лишь её существование.



Т.о. функциональные зависимости позволяют нам однозначно определять значения
один атрибутов на основе других. Т.е. можно найти такой набор атрибутов, от
которых все остальные зависят, т.е. определяются однозначно (по функциональным
зависимостям). Такой набор называется **возможным ключом**.

Возможный ключ называется **минимальным**, если из него нельзя ничего выкинуть.

Возможен случай, когда отношение имеет несколько минимальных ключей.

**Первичный ключ** - один из возможных ключей.

В любом отношении есть хотя бы один ключ благодаря наличию тривиальных
функциональных зависимостей (зависимость атрибута от него самого или любого
множества, его включающего).



### Нормализация

Если можно один набор отношений преобразовать в другой (и наоборот), то эти
наборы представляют одну и ту же информацию, поэтому **эквивалентны**.

Хотим выбрать такую схему, которая построена правильно и имеет вкусные свойства.



**Определение**: *Нормализация* - процесс устранения нежелательных свойств.

-   **Зависимость от неполного ключа**: если первичный ключ составной, то
    некоторые атрибуты могут зависеть от неполного ключа. В таком случае
    возникает аномалия, т.к. одинаковые значения неполного ключа приводят к
    одинаковым значениям атрибута. И это избыточность. Тогда можно заменить наше
    отношение на две проекции. После устранения этого получаем **вторую
    нормальную форму**.

-   **Транзитивная зависимость** - приводит к избыточности аномалиям, приём
    аналогичный: заменяем исходное отношение на две проекции, по которым можно
    восстановать исходное отношение, так что они эквивалентны. После устранения
    этого недостатка получаем **третью нормальную форму**.

-   Многозначная зависимость - зависимость не строк, а  групп строк. Если такие
    зависимости устранены, то говорят о **четвёртой нормальной форме**.

-   Если отношения невозможно разложить на проекции далее без потери информации,
    то говорят о **пятой нормальной форме**.

**Итого**: наибольшей НФ является пятая. Но в реальности дальше третьей никто не
идёт (Да и третья вызывает сомнения).
