Лекция 7-8
==========

Языки запросов в реляционной и табличной моделях
------------------------------------------------

Первые действительно высокоуровневые языки появились в связи с реляционной
моделью.

Начнём с реляционной алгебры. Алгебра потому что можно к результату операции
применить другую операцию, потому что применение операций не выводят элемент из
алгебры. Т.о. любой запрос - комбинация операций алгебры.

Реляционная алгебра - универсальная с частичными операциями.



### Операция ограничения

(более семантически оправданным является название "фильтрация")

Тут бывают простые условия, связывающие значения двух атрибутов или атрибута и
константы

-   `attr1 = c`

-   `attr1 = attr2`

-   Операторы: =, <, >, <=, >=, <>

Условия можно объединять с помощью логических выражений (`OR`, `AND`, `NOT`)

А ещё можно использовать... скобочки!



### Операция проекции

Взять и спроектировать на отношение меньшей размерности. При этом происходит
потеря строк, т.к. некоторые кортежи могли быть спроецированы в один и тот же.



>   Эквивалентные по результату алгебраические операции могут быть не
>   эквивалентными по вычислительной сложности. Например, если мы сначала
>   отбросим большую часть выборки, а потом что-нибудь с ней сделаем, то это
>   будет быстрее, чем если действовать наоборот.



>   К.О.: У нас есть почти все теоретико-множественные операции, окромя
>   дополнения. Ибо дополнение вполне может быть бесконечным.



### Соотношения между операциями

Замечательное свойство реляционной алгебры заключается в существовании таких
отношений. Именно на их существовании и основаны оптимизаторы запросов.

-   `restr(cond1 AND cond2) = restr(cond1) restr(cond2)`

-   `proj(A) restr(A = c) = restr(A = c) proj(A)`

-   И другие, см. слайды.



### Операция соединения

Прямое произведение с последующим ограничением.

>   Объединение и соединение звучат похоже (хотя `JOIN` и `UNION` совсем не
>   похожи), но являются совсем-совсем разными, не путайте их!

Есть ещё полусоединение: проекция естественного соединения на один из
аргументов.

А есть операция антисоединения: разность между первым аргументом и результатом
полусоединения. Смысл этой операции заключается в нахождении объектов без пары.



Рассмотрим операции, которые в реляционной алгебры... существовать не могут. А
все потому что реляционная алгебра не признаёт пустых значений, т.е. в кортежах
не может быть неопределённых значений. С теоретической точки зрения это так,
потому что невозможно универсально определить семантику таких значений. Вот,
например, равны ли два неопределённых значения?

А раз неопределённые значения - это плохо, то операции, производящие их в
большом количестве, ещё хуже.

При соединении, например, если кому-то нет пары, то в результат этот кто-то не
попадёт. Но иногда нужно найти не пару, а подтянуть дополнительную информацию.
Тогда нужно взять все элементы первого отношения, вне зависимости от наличия
пары. Решение, предлагаемое практическими инструментами, заключается в том, что
в резльтат добавлются все строки, которым не нашлось пары, недостающим атрибутам
устанавливаются неопределённые значения (`LEFT OUTER JOIN` зовётся такая
операция, аналогично `RIGHT OUTER JOIN` берёт все строки из второго отношения. А
`FULL OUTER JOIN` - и то, и то).

Операция соединения ассоциативна и коммутативна. Имеется дистрибутивные законы,
связывающие объединение с пересечением и объединением (?).



### Операция деления

Эта операция не реализована в современных программных продуктов. Но иногда её
можно выразить в терминах других операций (а, впрочем, можно даже в общем
случае).

Находим внутри делимого подмножество, являющееся прямым произведением делителя
на что-то, находя таким образом частное.

**Use case**: Исходная таблица — студенты c их жалкими попытками^W^W
сданными экзаменами. Делитель — список экзаменов. Частное — список студентов,
таки сдавших все экзамены.

**Use case #2**: задача состоит в том, чтобы выполнять запросы, в каждом из
которых может быть более 9000^W 30 критериев отбора, но какие именно из 33
использовать — решал пользователь. Очевидно, что различных комбинаций запросов
могло быть не просто более 9000², а более 81 000 000! Невероятный успех
заключается в отсутствии необходимости писать эти 8Gb запросов. А если бы запрос
генерировался, то получился бы запрос на пару мегабайт. Деление тут всё
зарешало, но *я прослушал, как*.



### Реляционное исчисление

Исчисление - более высокоуровневый язык, чем алгебра. "Задумано было так, что он
ближе к спецификациям, чем любой императивный код, он более декларативен."

Грубо говоря, в реляционном исчислении любой запрос записывается одной формулой.

Правила построения этой формулы строятся рекурсивно, как в формальной логике.

-   Переменные - значения атрибутов

-   Простые условия на значения

-   Логические выражения, скобочки

-   Кванторы даже



Запрос состоит из двух частей:

-   Левая часть - список переменных

-   Правая часть - выражение в реляционном исчислении

Замечательный факт состоит в том, что алгебра и исчисление эквивалентны. Т.е.
если исчисление реляционное и в нём нет рекурсии, то любой запрос исчисления
можно выразить в алгебре и наоборот.



### Алгебры

-   Поисковая алгебра (с полусоединениями)

-   Алгебра с соединениями - мощнее, чем поисковая

-   Реляционные языки - можно доказать, что реляционная алгебра не эквивалентна
    алгебре с соединениями

-   Рекурсивные языки (в реляционной алгебре нет рекурсии)



### А теперь поговорим об SQL

Существует международный стандарт SQL. Вышло несколько ревизий, но лучшее всего
прижился стандарт 92-го года.

**Данные в SQL**: Скалярные данные: числа, строки, даты и время, большие строки,
байтовые последовательности



>   *Тут идёт справка по языку SQL, почитайте слайды и посмотрите интернет.*
