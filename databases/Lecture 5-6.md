Лекция 5-6
==========



### Реляционная модель: ключи



...



### Нормализация методом декомпозиции

Заменяем исходное отношение на две проекции, из которых впоследствие
восстанавливается исходное.



4 и 5 НФ встречаются только в теории, на практике - нет.



Были попытки создать алгоритмы, которые будут самостоятельно нормализовывать
таблицы до 3НФ. Работают такие алгоритмы с функциональными зависимостями, а не с
отношениями. Существуют алгоритмы (даже полиномиальные), позволяющие построить
базис функциональных зависимостей. Далее определяется множество ключей, от
которых зависят все остальные.



Реляционная модель в её теоретическом смысле не имеет времени, т.е. является
неизменяемым. Если мы что-то меняем, то получаем новое отношение, никак не
связанное с предыдущим.



### Ограничения целостности

-   Первичный ключ: набор колонок, используемый для идентификации строки.
    Система обязуется гарантировать уникальность этого ключа (И, быть может,
    что-то ещё). Обычно это суррогатный ключ.

-   Уникальный ключ: набор колонок с уникальными значениями. Система
    гарантирует, что во всей таблице не будет дубликатов.

-   Внешний ключ: набор колонок, связывающих одну таблицу с другой. Это даёт там
    способ описания связей между объектами. Такие связи влияют на работу
    удаления, например: при удалении строчки, от которой зависит другая, её не
    дадут удалить, т.к. это действие приведёт к нарушению целостности. А если
    указать что-то в духе "ON DELETE CASCADE", то будет удалена и зависящая
    строчка.А есть ещё и лругие опции (в различных реализациях).



Объектные модели
----------------

Существуют и объектно-реляционные модели.



### Объектные расширения реляционной модели

-   Определение пользовательских типов. Теперь нельзя сравнивать килограмы с
    метрами.

-   Возможность определения составных типов

-   Можно определять коллекции; коллекция может быть значением некоторого
    аттрибута. Т.е. могут быть отношения не в 1НФ.



### Связи в объектной модели

Сильно урезанный вариант связей из модели "сущность-связь", т.к. связи всегда
бинарные. При этом объект одного типа может быть связан с несколькими объектами
другого типа. Система сама занимается поддержкой связей. (Ну и ограничения
целостности).



Устаревшие модели данных.
-------------------------

Сетевая модель данных (не имеет ничего общего с вычислительной сетью).

    -   Хранимые объекты - записи, представляющие сущности, фиксированной
        структуры и длины

    -   Есть наборы (вместо связей)

    -   Каждый набор связывает два типа записей: владельца набора и члена
        набора.

    -   Использовались диаграммы Бахмана для описания структуры БД

    -   Такая модель считалась более эффективной, т.к. перейти по указателю
        можно быстрее, чем найти что-либо.

    -   Операции: создание, обновление, удаление записей, включение / выключение
        из набора

    -   Ограничения целостности:

        -   Каждая запись обязательно является членом какого-либо набора. Т.е.
            при создании запись включается в некий набор.

        -   Обязательное удаление всех членом набора при удалении владельца.



Отображение моделей данных
--------------------------

Структуры обычно отображаются без потерь. А отображения нужны, т.к. удобнее
всего начинать проектирование с модели сущеость-связь, а потом отобразить её в
модель нашей системы.



### Самое простое: отображение реляционной модели в табличную

Делать тут ничего не надо, ибо табличная отличается от реляционной тем, что
табличная не накладывает особых ограничений. Проблемы могут быть с обратным
переводом.

Отношения представляются таблицами. Ограничения целостности можно перенести.
Если таблицы получены из отношений, то семантика операций сохраняется.



### Отображение таблиц в отношения

-   Нужно избавиться от дубликатов

-   Возможно потребуются суррогатные ключи

-   Некоторые опреации табличной модели не отображаются в реляционной



### Отображение модели плоских файлов в табличную модель

Тут всё просто.



### Отображение объектных расширений в табличную модель

Вложенные коллекции выносятся в отдельную таблицу (по аналогии со вложенными
таблицами). Можно сразу сделать первый шаг нормализации, вынеся внутренние
таблицы во внешнюю и обеспечив нужные связи с помощью внешних ключей.

Самый сложный вопрос, связанные с объектными расширениями, - это отображение
наследования. Если имеется иерархия наследования (некий объект является
расширением другого), то это модно представить несколькими способами:

-   Можно хранить все объекты в одной таблице, содержащей все поля всех
    наследников. У некоторых записей будут пустые поля.

-   Можно для каждого типа заводить отдельную таблицу (Либо будет дублирование,
    либо будет сложно собрать всю релевантную информацию)

-   А можно как-то ещё



Если модели можно конвертировать друг в друга, то они в некотором смысле
эквивалентны.



### Отображение модели сущность-связь в реляционную

-   Атрибуты остаются атрибутами.

-   Множества сущностей становятся отношениями.

-   МНожество связей тоже.

-   Ключ остаются ключами.

-   Операций в ER нет.

А что делать с функциональными зависимостями? В модели сущность-связь их нет, а
в реляционной модели они нужны, ибо нормализацию проводить надо. Так вот: если
мы правильно выделили сущности и правильно установили связи, то зависимости
(существующие в реальном мире) уже учтены. Считается, что все атрибуты
функционально зависят только от первичного ключа.



### Отображение модели сущность-связь в сетевую

Отобразить связи многие-ко-многим так просто в сетевую модель не получится.
Нужно вводить дополнительные типы записей, представляющие связи.



На этом отображения закончились. А теперь...



Тернарная модель данных
-----------------------

Замечательная модель, показывающая ненужность всего предыдущего.

Все данные организуются в виде троек. Первый атрибут - некий идентификатор
объекта. Вторая "колонка" - имя атрибута. Третья - значение атрибута (может быть
и ссылка на другой объект, т.е. можно представлять графы).

-   Можно записывать данные, ничего не зная об их структуре, т.к. схемы нет.

-   Никаких ограничений на связи.

-   Тыщу раз изобреталась, сотни раз публиковалась. Использовалась в 70-х годах
    для реализации ИИ.

-   Ныне примерно то же самое делается в связи с семантическим Web в рамках RDF.

-   На неё можно без труда отобразить любую другую модель.



Недостатки у такой модели то же есть. Если мы можем представить всё, что угодно,
то и ошибки будут храниться так же бережно, как и правильные данные. Нельзя
ввести типизацию значений, нельзя устроить сортировку или поиск, т.к. неизвестен
сортируемый тип. Нельзя проверить ссылочкую целостность для отслеживания
корректности взаимосвязей. Ну и этот способ представления и хранения приводит к
тому, что получается слишком много слишком мелких данных, которые сложно быстро
обрабатывать быстро



Не надо изобретать эту модель в 1001-й раз.



Бинарная модель данных
----------------------

Отдельная таблица на каждый атрибут. Таблица содержит две колонки: идентификатор
объекта и значение соответствующего атрибута.

При анализе данных требуется работать с оооочень большими данными, так что
проводить какие-нибудь объединения очень накладно. Поэтому данные хранятся с
большим количеством колонок в ненормализованной форме. В то же время, далеко не
всегда требуются все колонки.



Другие модели данных
--------------------

-   Табло - таблица, где в некоторых строчках некоторые колонки могут
    отсутствовать

-   XML - современный (хоть и не очень модный) иерархической модели

-   Большие графы

-   Массивы данных - хранение и выполнение операций над большими массивами
    (временные ряды, температура за последние 10 лет) для нужд науки



На этом обзор моделей заканчивается.
