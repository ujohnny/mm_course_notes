

Базы данных и СУБД
==================

Новиков Борис Асёнович

Интересные ссылки:

-   [http://www.math.spbu.ru/user/Boris_Novikov/][1]

-   [http://www.math.spbu.ru/SD_AIS/][2]

-   [http://meta.math.spbu.ru/][3]

[1]: <http://www.math.spbu.ru/user/Boris_Novikov/>

[2]: <http://www.math.spbu.ru/SD_AIS>

[3]: <http://meta.math.spbu.ru/>



Список **рекомендованной литературы** можно найти в слайдах. А книга
Гарсиа-Молина очень хороша. Книга Дейта тоже годна, но несколько одностонняя.

Рассматривать преимущественно будем большие и средние системы, маленькие не
интересны.



Имеются лекции некоего С.Д. Кузнецова, которыми, сюрприз!, тоже можно
пользоваться. Книжка самого Новикова, упомянутая в списке литературы, является
скорее дополнительным чтением, ибо содержит темы, которые не освещаются в курсе
и не выносятся на экзамен. Пользоваться книгами а-ля "для чайников" не следует.
И документацию по конкретным системам не следует использовать для подготовки.
Как бы то ни было, список **не**рекомендуемой всё так же приведён в слайдах.



Введение
--------



А зачем БД и СУБД вообще нужны? Вообще, появились они в середине 60-х годов
прошлого столетия. Тогда появлялись приложения, работающиес большим количеством
данных, которые не помещались в оперативную память. А ещё они очень важные и
ценные. Необходимость работать с такими данными и привела к появлению БД.



### История и мотивация

До 1965 года наиболее распространены были ленточные системы. По-сути, лента -
это файл.

Позже появились устройства прямого доступа (диски то бишь), которые уже
позволяли точечные изменения, не требующие полной перезаписи для одиночного
небольшого исправления. Однако, после такого изменения мы теряем предыдущую
копию, т.е. бекапы надо делать руками.



В слайдах имеется рисунок, в котором описывается схема взаимодействия приложений
в БД. Если же у нас есть СУБД, то количество связей уменьшится. И это хорошо!

-   

### Ок, а чего мы хотим от СУБД?

Давным-давно в далёкой-далёкой галактике был создан документ, опеределяющий
требования к базам данных. Чем больше таких требований выполнено, тем лучше:

-   Независимость программ и данных - возможность независимо от приложения
    описать (на специальном языке описания данных) логическую структуру данных.
    Далее, для каждого приложения определетяется доступное ему подмножество
    данных, так что мы можем менять структуру данных, не меняя приложения (т.к.
    оно не знает о чужих данных).

-   Поддержка целостности данных - приложения приходят, что-то делают с данными
    и уходят. Т.о. приложения приходят и уходят, а данные - вечны! Зачастую
    данные дороже программ (которые без данных бесполезны), так что хранить их
    надо аккуратно. Язык описания данных обычно позволяет задавать т.н.
    *ограничения целостности*. Задачей БД в таком случае является контроль за
    выполнением этих ограничений. Ещё могут быть зависимости на данные, например
    (Скажем, оценка за экзамен должна быть привязана к студенту и сдаваемому им
    предмету). А то и что-то ещё.

-   Согласованность - существует ооочень тонкая грань между согласованность и
    целостностью.

-   Язык запросов - обеспечивают возможность работы с данными на основе
    высокоуровнено декларативного языка запросов. Мы ещё поговорим более
    конкретно и предметно о них.

-   И некоторые другие, смотри слайды

>   Примечание: ФС - это не БД! БД должна иметь представление о логической
>   структуре данных, а ФС не знает этого в достаточной мере.



А теперь поговорим о...

### Язык описания данных

О конкретных языках поговорим позже.



-   Внешняя схема - схема уровня приложения. Может содержать не все данные,
    может предоставлять их в другой форме, например, отсортированной. Или даже
    вычислять данные. Т.е. в базе их нет, но возвращаем мы что-то, вычисленное
    на основе хранимых.

-   Концептуальная схема -

-   Схема хранения - описывает представление концептуальной схемы на носителях
    данных



### Взаимодействие приложений и СУБД

Самой традиционной схемой является клиент-серверная модель.

Сервер работает в стиле "спим - к нам пришли за данными, просыпаемся -
обслуживаем запрос - посылаем ответ - спим дальше". Ну, это крайне очевидный
подход, ибо СУБД мы хотим иметь одну, а приложений - много.

В данном курсе слова "клиент" и "сервер" обозначают роли процессов.



`/* ля-ля-ля, тут я гулял */`



### Многослойная система

Такие системы хороши в условиях большого количества клиентов. Например, в случае
веб-приложений.



Давайте же, наконец, определим базу данных. Иногда люди используют эти термины
взаимозаменяемы. Тем не менее, у этих слов есть "оттенки смысла".

**Определение**: *базой данных* называется совокупность данных, хранящаяся в
системе, вместе с их описаниями.

**Определение**: *системой управления базой данных* называется программный код,
обеспечивающий доступ к базе данных.

**Определение**: Сервер БД - система (запущенное приложение), которая находится
в ожидании запросов от клиентов.

**Определение**: Экземпляр БД - сервер БД вместе с самой БД.

>   Убедительная просьба: используйте эти слова правильно.



>   А ещё необыкновенно часто на экзамене встречается такой забавный термин
>   "мы". А-ля "А вот сейчас *мы* сделаем вот такую операцию". В какой роли в
>   данный момент находится отвечающий - неизвестно.



### Компоненты СУБД

-   Ядро, выполняющая роль сервера БД

    -   Компилятор языка описания данных, работающий в рамках ядра

    -   Исполнитель запросов, интерпретатор языка запросов, тоже где-то в ядре

-   Имеются сервисные утилиты-программы для работы с БД

-   Средства поддержки сохранности БД



### Архитектура БД

Классифицируем БД по архитектуре:

**Централизованные БД** - предполагается, что сервер БД работает на одной
вычислительной системе (что бы это ни значило).

Высокопроизводительные БД могут являться **параллельными**. Приложению при этом
они представляются единой сущностью, но "внутри" являют собой несколько
отдельных БД. При этом внешне параллельная система неотличима от обычной
централизованной. Какой-нибудь Оракл, например, может, будучи поставленным на
многопроцессорную систему, без проблем использовать все доступные мощности, а
пользователь этого и не заметит. С точки зрения алгоритмов, с параллелизмом всё
тоже обстоит хорошо, алгоритмы хорошо параллелялтся.

**Распределённые БД** состоят из нескольких серверов

Не стоит путать параллельные и распределённые системы, хотя чёткой границы между
ними нет и на одной системе можно создать и ту, и ту. При этом распределённая
система решает другую задачу: если параллельная целится на производительность,
то распределённая - на *доступность* и *надёжность*. При этом централизованная
система не может быть доступна 100% времени (ибо надо обновлять её, например). С
распределёнными такое теоретически возможно (Но крайне маловероятно на практике,
ведь в теории между практикой и теорией разницы нет, а на практике есть :-) ).



### Конкретные СУБД

Их не обещали, но они есть

-   Высокопроизводительные - хорошие системы. Обеспечивают на хорошем
    оборудовании выоскую надёжность, стабильность и всё другое.

-   Недорогие - для их запуска не требуется значительных финансовых вложений.
    Зачастую приходится совершать различные танцы с бубнами для обеспечения
    приемлемой производительности, надёжности прочего. В общем, скупой платит
    дважды.

>   **Реклама!** PostreSQL находится где-то посередине. *Т.е. дорогая в
>   поддержке и плоха в производительности, вестимо - Невероятно Важный
>   Комментарий стенографиста. Впрочем, всё здесь является моим комментарием*

>   А самая дорогая и крутая - IBM DB2

>   А ещё хорошая БД от Оракла. Развивалась с конца 70-х, а в 80-х уже работала
>   вообще везде.

>   В последние годы подрос и окреп MS SQL. Ходят слухи, что с Действительно
>   Большими данными это чудо не справляется. Распространённое мнение гласит "Ну
>   система слега подешевле, но не годится для действительно больших БД"

Есть ещё множество других БД, которые не целятся на большую производительность,
например, MySQL, получившая большое распространение, например, как простенькая
БД для веб-сайтиков.

Высокопроизводительные системы внутри имеют крутые и слоооожные алгоритмы
(которые, наверное, ещё и патентными троллями охраняется). Даже в Postgre
некоторые вещи делаются довольно глупо, DB2 или Оракл делают это лучше.



Размеры самых больших по объёмам данных БД измеряются сотнями Тб и, в общем-то,
не растут более. Это, например, БД больших сетей магазинов, которые знают
содержимое каждой корзины, проходившей мимо кассы. А если оплата производилась
картой, то всё о вас уже известно :-) Не растут такие базы преимущественно
потому, что ни кого не интересует, что покупали 20 лет тому назад. А данные эти
можно использовать в целях их анализа и выявления интересных фактов (Например,
корреляции между пивом и подгузниками, см. гугл).

А на бирже, например, спокойно может быть 10 000 000 000 запросов в сутки. И
распределённая СУБД от Оракла с таким справляется.



На этом введение закончилось. В процессе введения мы разобрались в БД и их
местом в нашем мире.



Модели данных
-------------

**Определение**: *модель данных* есть совокупность средств, которые необходимы
для описания структур данных. Мы будем, преимущественно, говорить о моделях в
этом смысле.

**Определение**: *моделью данных* можно считать конкретное описание конкретной
области применения.



### Что входит в состав модели?

-   Описание типов элементов данных

-   Способов их группировки в более сложные единцы

-   Способы описания взаимосвяжей

-   Способы описания ограничений целостности

-   Операции



### Модели выбают разные

-   Модель плоских файлов

-   Сетевая (позволяет представлять графы)

-   Иерархическая (xml, например)

-   Реляционная

-   Табличная (в быту совпадает с предыдущем)

-   Объектная модель

-   Экзотические (бинарная, тернарная)

-   Модель "Сущность-связь"

-   И другие...



>   **Проблема**: программисту удобнее работать с объектами и навигацией, т.е.
>   переходить от объекта к объекту посредством их связей. Однако, базе данных
>   такой подход не удобен, т.к. лучше выполнить один большой запрос, а не много
>   маленьких. И это техпологическая проблема.



### Идентификация

Для работы с объектами их нужно идентифицировать. И модель какой-то способ
идентификации предусматривает.

1.  **Естесственная идентификация** - идентификация объекта по его естесственным
    свойствам. Однако, крайне редко такая идентификация обеспечивает
    уникальность.

2.  **Суррогатная идентификация** - введение внутреннего уникального
    идентификатора. Однако ж, это лишь перенесение проблемы с одного уровня на
    другой, проблемы будут за пределами системы.

3.  **Позиционная идентификация** - идентификация по местоположению объекта.
    Весьма неудачная форма идентификации, ибо объекты от перемещения, вообще
    говоря, не меняются.



Закончили расммотрение общих свойств. Переходим к конкретным моделям.



### Модель "сущность-связь" (entity-relationship)

П. Чен в 1975г. опубликовал эту модель для высокоуровнего проектирования ЬД.

Не позволяет описывать операции, но можно описывать ограничения целостности,
например.

Значение этой модели уменьшилось, ибо на её основе были построены многие
объектные модели.



>   Сущность - нечто внутренне, противоположность явлению, которое есть
>   проявление сущности.



**Определение**: *сущность* (entity) - объект реального мира, однозначно
отделимый и отличимый от других сущностей.

>   А это определение требует решения проблемы идентификации. Т.е. сущность
>   должна иметь некий уникальный идентификатор.



**Определение**: Свойства сущности зовутся *атрибутами*.

Атрибуты являются атомарными (или скалярными), т.е. дальше они не
структурируются (в модели).



Сущности могут быть похожимы друг на друга, т.е. имена атрибутов одинаковы
(значения, тем не менее, могут быть различны). А похожие сущности можно
объединять в множества.

>   Никаких методов тут нет, т.к. нет операций.
