Лекция 3
========



Попробуем реализовать алгоритм перевода в двоичную систему исчисления. Но так
просто сделать это не получится, т.к. числа по модулю $2^{32}$. Но есть
вспомогательные функции, которые могут быть полезны.

`<NUMB 234> = '234'` - выдаёт по числу его строковое представление

`<SYMB '234'> = 234` - выдаёт число по строковому представлению

Напишем

`<NUMBALL -1 234> = '-1 234'`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NUMBALL {
    '-' e1 = '-' <NUMBALL e1>;
    s1 e1 = <NUMB s1> ' ' <NUMBALL e1>;
          =  
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`<SYMBALL '-1 234'> = '-'1 234`

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SYMBALL {
    '-' e1 = '-' <SYMBALL e1>;
    s1 = <SYMB s1>;
    e1 s2 = <SYMBALL e1> <SYMB s2>;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



А теперь, собственно, виновник торжества

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to2 {
    0 = '0';
      =    ;
    '-' e1 = '-' <NUMBALL<e1>>;
    e1, <mod(e1)2>:0 = <to2<div(e1)2>> '0';
    e1 = <to2<div(e1)2> '1';
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это какой-то бред, оно не работаэ.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to2_23 {
        =  ;
    '0' = 0;
    '1' = 1;
    '-' e1 = '-' <to2_32 e1>;
    e1 s2 = <ADD(<NUMB s2>)<MUL(<to2_32 e1>)2>>;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Рефал был создал для структурированных текстов. Вот ими и займёмся

Пример дерева:

Скобки тоже надо писать в кавычках, но не обязательно.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
('ab'('c'))'de'(())
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  .    .   .
 / \  de  (())
ab (c)      |
    |       ()
    c       |
           \Lambda
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Алгоритм деструктуризации: замена круглых скобок (которые, кто бы мог подумать,
хранят адрес правой скобки) на прямоугольные скобки (которые ничего не хранят).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
des {
    e1(e2)e3 = e1 '[' e2 ']' e3;
    e1 = e1;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Теперь надо написать обратную программу, реструктуризации.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
str {
    e1 ']' e2 = <str <v e1 ()> e2>;
    e1 = e1;
}

v {
    e1 '[' (e2) = e1(e2);
    e1 t2 (e3)  = <v e1 (t2 e3)>;
    (e1) = <PROUT 'Error in ' e1 ': absense of ['>;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Тип `t` означает либо символ, либо что-то в скобках.
