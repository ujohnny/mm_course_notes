Лекция 7
========

Пусть у нас есть некое множество X, элементы которого упорядочены. Иначе не
очень понятно, как его представлять, т.к. при наличии порядка можно представить
это множество в виде характеристических векторов (см. определение далее),
например.



**Задача 1**: сгенерировать все подмножества X в лексикографическом порядке.

**Определение**: *характеристическим вектором* называется вектор, у которого
i-ая компонента равна 1, если элемент имеется в множестве и 0, ежели это не так.



>   **Задание**: дать определение лексикографического порядка на подмножествах.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
program Set1;
const n = ...;
var s: array[1..n+1] of 0..1;
    i, j: integer;
begin
    for i := 1 to n+1 do s[i] := 0;
    while s[n+1] = 0 do begin
        Print(s);
        i := 1;
        while S[i] = 1 do begin
            s[i] := 0;
            i := i + 1;
        end;
        s[i] := 1;
    end;
end.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Но это плохо тем, что иногда сразу куча элементов то выпадает из множества (при
переходе от представления вида 01...1 к 10...0). Поэтому на помощь спешат...
коды Грея!



Можно написать их рекурсивно, ибо само определение рекурсивно

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
program Set2;
const n = ...;
var s: array[1..n] of 0..1;
    i : integer;
procedure Gray(m: integer);
begin
    if m = 0 then
        Print(s);
    else begin
        Gray(m-1);
        s[m] := 1 - s[m];
        Gray(m-1);
    end;
end;

begin
    for i := 1 to n do S[i] := 0;
    Gray(n);
end.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   **Задание**: сколько раз вызывается процедура `Gray`?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
program Set3;
const n = ...;
var s:array[1..n] of 0..1;
    i, j, k, p: integer;
begin
    for k := 1 to n do s[k] := 0;
    i := 0;
    repeat
        Print(s);
        i := i+1;
        p := 1;
        j := i;
        while j mod 2 = 0 do begin
            j := j div 2;
            p := p + 1;
        end;
        if p <= n then
            s[p] := 1 - s[p];
    until p > n;
end;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   **Задание**: сколько раз работает проверка `j mod 2 = 0`

А как эту программу можно улучшить? А вот можно избавиться от цикла `while`.
Если n невелико, то коды Грея можно хранить в машинных словах и пользовать
битовые операции.



Есть ещё один вариант такой прогррамы, который я поленился записать.



**Определение**: Мультимножеством называется такое множество, в котором
некоторые элементы могут повторяться.

Заведём массив, который будет отражать, сколько раз повторяется каждый элемент.

>   **Задание**: Написать программу для генерации мультимножеств, где каждый
>   элемент может повторяться от 0 по n раз.



>   **Задание**: написать генерацию множеств так, чтобы каждое следующее
>   отличалось вставкой или удалением одного элемента.



Перейдём теперь к k-подмножествам данного множества. Хотелось бы генерировать их
добавлением и удалением одного элемента.

>   **Задача**: just do it!
