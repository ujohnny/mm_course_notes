Лекция 5
========

...



Сколько раз будет изменено минимальное значение в следующей программе?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
m := a[1];
for i := 2 to n do
  if a[i] < m then
    m := a[i];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

$H_n-1$ ибо тут важно количество перестановок в среднем.



Количество перестановок типа $\alpha$:

$$
A_\alpha = \frac{n!}{1^{\alpha_1} \alpha_1! \cdot 2^{\alpha_2} \alpha_2! \cdot \dots \cdot n^{\alpha_n} \alpha_n!}
$$

Это почти очевидно из общих соображний: циклы определённого типа можно
переставлять ($\alpha_i!$), а их содержимое можно циклически сдвигать
($k^{\alpha_k}$).



### Тождество Коши

$$
\sum_{\alpha} \frac{1}{\prod_{k=1}^n k^{\alpha_k} \alpha_k!} = 1
$$

Любая перестановка какого-нибудь типа. Ну а мы суммируем их все.



### Представление перестановок в виде таблицы инверсий

Возьмём какую-нибудь перестановочку, например, $<2 4 5 7 3 1 6>$

Сопоставим ей таблицу инверсий, которая будет означать количество элементов,
меньших i-го. предшествующих ему: $/5 0 3 0 0 1 0/ $(странно, но это называется
**таблицей перестановок**, хотя таблицей не является)

$r_i$ = количество элементов $f$, больших $i$, стоящих перед $i$



Утверждается, что в среднем в перестановке $\frac{n(n-1)}{4}$ инверсий. Но
сперва следует показать взаимнооднозначность таблиц инверсий и перестановок.



**Теорема** (Холл, 1957): таблица инверсий однозначно определеляет перестановку.

**Доказательство**:

Таблица инверсий однозначно определяетс по перестановке, очевидно это.

А ежели у нас есть таблица, обрадающая свойством $0 \le r_i \le n-i$, то

Вообще, можно придумать алгоритм для восстановления перестановки по таблице
инверсий. Можно придумать тривиальный алгоритм с вставкой элемента на правильную
позицию, а можно хитрый, о котором пишет сам Кнут. Этот алгоритм аккуратно
записан в конспекте. Для эффективной реализации можно использовать "обратный
список", когда значением будет идекс, а в массиве лежит номер следующего.

Сложность обоих алгоритмов $O(n^2)$, но лучше и не сделать, ибо инверсий-то в
среднем столько же.

Лучшее, чего можно добиться - $O(n log n)$, ибо можно связать с задачей
сортировки.

>   BTW, если кто не в курсе: $O(\log_2 n!) = O(n \log n)$. Можно даже доказать
>   $n \ln n - n + 1 < \ln n! < (n+1) \ln n -n + 1, n > 1$
