Лекция 3
========

Рассмотрим программы генерации каких-либо теоретико-множественных объектов
(перестановок, например). Её ёмкостная и временная сложности будут $O(n!)$. Как
оценивать алгоритмы?



### Генерация перестановок в лексикографическом порядке

$S = {1, \dots, n}$

Для представления перестановки, очевидно, нужно использовать массив из $n$
элементов. Обозначение: $<a_1, \dots, a_n>$

Если $a = <a_1 \dots a_n>$, $b = <b_1 \dots b_n>$, то мы пишем $a < b, если
\exists 1 \le k \le n: \forall i < k \; a_i = b_i, \; a_k < b_k$

Тут были выписаны все перестановки $<1 2 3 4>$ в лексикографическом порядке, но
я слишком ленив, чтобы переписывать их.

Заметим, что

1.  Лексикографически наибольшая перестановка есть перевернутая наименьшая.

2.  Все перестановки можно разбить на n классов (групп) перестановок, считая
    перестановки принадлежащими одному классу, если совпадают их первые
    элементы. Внутри одной группы, таким образом, элементы, начиная со второго и
    далее, образуют перестановки в лексикографическом порядке.

Теперь задача генерации "не сложнее задачи Ханойской башни".

Неплохо бы иметь процедуры

-   `Lec(k)`

-   `Invert(m)` - переворачивает хвост (от m до n)

-   `Print(s)` - печать перестановки

>   Желающие углубить свои познания в комбинаторике могут ознакомиться с книгой
>   Липский, Комбинаторика для программистов

**!!! WARNING !!! DANGER !!! ALERT !!!** Программа на паскале!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Program Lex1;
const n = 15;
var p:array[1..n] of 1..n;
    i, r : 1..n;

procedure INVERT(m: integer);
var i, j : 1..n;
begin
    i := m;
    j := n;
    while i < j do begin
        r := p[i];
        p[i] := p[j];
        p[j] := r;
        i := i + 1;
        j := j - 1;
    end
end

procedure LEC(k: integer);
var i: integer;
begin
    if k = n then
        PRINT(p)
    else
        for i := n downto k do begin
            Lec(k+1);
            if i > k then begin
                r := p[i];
                p[i] := p[k];
                p[k] := r;
                INVERT(k+1)
            end
        end
end

{ Сама программа }
begin
    for i:=1 to n do p[i] = i;
    Lec(1);
end.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В среднем $\cosh 1$ транспозиций при переходе.



Обозначим $T_n$ - число транспозиций для генераций всех перестановок n порядка.
Тогда

$$
T_n = n T_{n-1} + (\lfloor \frac{n-1}{2} \rfloor +1) (n-1)
$$

$$
T_1 = 0
$$

Очевидно получается из имеющихся свойств. Из второго свойства следует первый
терм. $(n-1)$ переходов между стобиками (группами), на каждый $(n-1)/2$
транспозиций на `INVERT` и ещё одна на изменение ведущего символа.

Решать в таком виде сложно, поэтому сделаем такое:

$$
S_n = T_n + \lfloor \frac{n+1}{2} \rfloor
$$

$$
S_1 = 1
$$

$$
S_n = n (S_{n-1} + \delta_{n-1})
$$

где $\delta = ((n+1) \mod 2)$ - символ Кронекера?



Тогда

$$
S_n = n! \sum_{j=0}^{\lfloor \frac{n-1}{2} \rfloor} \frac{1}{(2j)!}
$$

$$
\frac{S_n}{n!} \rightarrow \cosh 1
$$

Но можно и лучше. Романовский, наверное, рассказывал, как генерировать их с
помощью одной транспозиции.



А если итеративно? А давайте!

Давайте попробуем по текущей перестанвоки понять, как выглядит следующая.

$p_{current} = <a_1 \dots a_k \dots a_j \dots a_n>$

Найдём $k : \forall i > k a_i > a_{i+1}$. Отсюда будем переворачивать.

Найдём $j: \forall i > j \; a_i < a_k, a_j > a_k$.

Тогда

$p_{next} = <a_1 \dots a_{k-1} a_j a_n \dots a_{j+1} a_k \dots a_{k+1}>$

Тут мы заплатим за поиск $j$ и $k$.

**!!! ALERT !!! DANGER !!! WARNING !!!** ЕЩЁ КОД НА ПАСКАЛЕ!!1

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Program Lex2;
const n = 16;
var p: array[0..n] of 0..n;
    k: 0..n;
    j, z,m: 1..n;
begin
    for k := 0 to n do p[k] := k;
    k := 1;
    while k <> 0 do begin
        PRINT(p);

        k := n-1;
        while p[k] > p[k+1] do k := k - 1;

        j := n;
        while p[k] > p[j] do j := j - 1;

        r := p[k]; p[k] := p[j]; p[j] := r;
        j := n; m := k + 1;
        while i > m do
        begin
            r := p[j];
            p[j] := p[m];
            p[m] := r;
            j := j - 1;
            m := m + 1;
        end
    end
end
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



$$
C_1 = 0
$$

$$
C_n = n C_{n-1} + (n-1) (n-1) + 1 + 2 + \dots + (n-1) = n C_{n-1} + \frac{3 n - 2}{2} (n-1)
$$

Формула для *непонятно чего*. А ещё более непонятная такая:

$$
D_n = C_n + \frac{3n+1}{2}
$$
