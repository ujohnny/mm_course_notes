Анализ алгоритмов, лекция №2
----------------------------

На прошлой паре была задача: написать программу, быстро возводящую некоторое
число `x` в некоторую натуральную степень `n`.

Вот решение:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    read R1     read(n)
    read R2     read(x)
    load =1
    store R3    y := 1
    load r1
    jzero 1     while n <> 0
2:  div =2      do begin
    store r4    n1 := n div 2
    add r4
    sub r1
    jzero 3     if odd(n)
    load R2     then
    mult R3
    store R3    y := y * x
3:  load R2
    mult R2
    store R2    x := x * x
    load R4
    store R1    n := n1
    jzero 2     end
1:  write R3    write(x)
    halt
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Введём такую ненужную функцию, которая будет означать вес операции, ибо
некоторые операции дороже других.

$$
l(i) = \log_2 \lfloor |i| \rfloor + 1, \quad i \neq 0 else 1
$$

Утверждается такое

+-----------+-------------------------------+
| Операция  | Вес                           |
+-----------+-------------------------------+
| `=i`      | `l(i)`                        |
+-----------+-------------------------------+
| `i`       | `l(i) + l(c(i))`              |
+-----------+-------------------------------+
| `*i`      | `l(i) + l(c(i)) + l(c(c(i)))` |
+-----------+-------------------------------+
| `STORE i` | `l(c(0)) + l(i)`              |
+-----------+-------------------------------+

>   Я это рассказываю для формальности, но никто этим не пользуется

Есть т.н. символы Дирихле, т.е. О-большое и о-малое, про которые есть интересная
таблица

+-------------------------+---------------------+-------------------------+
|                         | **Равномерный вес** | **Логарифмический вес** |
+-------------------------+---------------------+-------------------------+
| **Временная сложность** | $O(\log n)$         | $O(n \log x \log n)$    |
+-------------------------+---------------------+-------------------------+
| **Ёмкостная сложность** | $O(1)$              | $O(n \log x)$           |
+-------------------------+---------------------+-------------------------+

**Определение**: *РАСП-машина* - машина с равномерной адресацией и с хранимой
программой.

**Теорема**: для любой РАМ программы можно построить эквивалентную ей РАСП
программу, при этом их сложности (любые) будут линейно связанны.

**Доказательство**: смотри Ахо-Ульмана.

МТ-машина
=========

Общеизвестно, что для любой многоленточной машины Тьюринга можно построить почти
эквивалентную ей одноленточную МТ.

**Определение**: *машиной Тьюринга* назовём такую штуку

$$
МТ = (Q, T, I, \sigma, b, q_0, q_f)
$$

где

-   $Q$ - конечное множество состояний

-   $T$ - алфавит всех лент

-   $I \subset T$ входной алфавит

-   $b$ - пустой символ

-   $\sigma: Q \times T^K \rightarrow Q \times (T \times {R, L, S})^K$ -
    отображение. Если эта функция однозначна, то МТ *детерминирована*, иначе -
    *недетерминирована*.

**Определение**: *K-ленточной* МТ называется такая штука:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|_|_|_|_|_|_|_|   <-- ячеечки, это входная лента

|_|_|_|_|_|_|_|
|_|_|_|_|_|_|_|
|_|_|_|_|_|_|_|   <-- рабочие ленты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Ещё определение**: *конфигурацией МТ* $\alpha$ называется `K` слов

$$
x_1^1 \quad ... \quad q x_{i_1} \quad ... \quad x_{n_1}
$$

$$
\vdots \quad ... \quad \vdots \quad ... \quad \vdots
$$

$$
x_1^k \quad ... \quad q x_{i_k} \quad ... \quad x_{n_k}^k
$$

*Комментарий*: типа K слов, по одному на каждой ленте. `q` обозначает позицию
головки.

Обозначения:

$$
\alpha \rightarrow \beta - \text{переход за один такт}
$$

$$
\alpha \overline{*}\rightarrow \beta - \text{переход за несколько тактов}
$$

$$
\alpha_0 \overline{*}\rightarrow \alpha_f
$$

Известно, что МТ может заканчивать работу, может "ломаться", может работать
бесконечно долго.

**ДЗ**: построить одноленточную МТ, проверяющую скобочную последовательность на
правильность (ожидаемая временная сложность $O(n^2)$). А ещё можно построить
двухленточную МТ, работающую за $O(n)$

**Определение**: $f_1(n)$ и $f_2(n)$ *полиномиально связаны* или *почти
эквивалентны*, если существуют такие 2 полинома $p_1(x)$ и $p_2(x)$, что для
любого $n$ справедливы неравенства:

$$
f_1(n) \leq p_1(f_2(n))
$$

$$
f_2(n) \leq p_2(f_1(n))
$$

**Пример**: $f_1(n) = n^2$, $f_2(n) = n^5$. Тогда $p_1(x) = 2x$, $p_2(x) = x^3$

**Ещё**: $n^2$ и $2^n$ **не** эквивалентны. *Уметь доказывать на экзамене на
пятёрочку!*

**Теорема (о связи МТ и РАМ машины)**: Для любой РАМ-прогарммы, не содержащей
команд умножения, можно построить эквивалентную ей МТ, при этом вычислительная
сложность (как емкостная, так и временная; как при равномерном, так и
логарифмическом весе) будут полиномиально связаны и обратно. Если программа
содержит команды умножения, то можно построить эквивалентую ей МТ, то при оценке
с равномерным весом полиномиально эквивалентной МТ не существует.

>   Тут было лирическое отступление про классы P и NP. На экзамене уметь
>   приводить примеры задач из этих классов. Например, проблема изоморфизма
>   графов.
